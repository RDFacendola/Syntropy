
/// \file functional.h
/// \brief This header is part of the Syntropy language module. It contains definitions for functional-style templates.
///
/// \author Raffaele D. Facendola - November 2020

#pragma once

#include "syntropy/language/foundation/types.h"
#include "syntropy/language/foundation/references.h"
#include "syntropy/language/templates/traits.h"
#include "syntropy/language/templates/sequence.h"

#include "syntropy/language/support/details/functional_details.h"

// ===========================================================================

namespace Syntropy::Functional
{
    /************************************************************************/
    /* FUNCTIONAL                                                           */
    /************************************************************************/

    /// \brief Apply a function passing the VIndex-th element of each tuple-like object as function arguments.
    /// \remarks Tuple elements are accessed by means of Get<Int>(tuple) function, which is expected to be defined for each type in TTuples.
    template <Int VIndex, typename TFunction, typename... TTuples>
    constexpr decltype(auto) ApplyAt(TFunction&& function, TTuples&&... tuples) noexcept;

    /// \brief Apply a function to all argument list generated by projecting the i-th element of all provided tuples, in the same order, for each index i.
    /// \remarks Tuple elements are accessed by means of Get<Int>(tuple) function, which is expected to be defined for each type in TTuples.
    template <typename TFunction, typename TTuple, typename... TTuples>
    constexpr void ApplyLockstep(TFunction&& function, TTuple&& tuple, TTuples&&... tuples) noexcept;
}

// ===========================================================================

namespace Syntropy::Functional
{
    /************************************************************************/
    /* IMPLEMENTATION                                                       */
    /************************************************************************/

    // Functional.
    // ==========

    template <Int VIndex, typename TFunction, typename... TTuples>
    constexpr decltype(auto) ApplyAt(TFunction&& function, TTuples&&... tuples) noexcept
    {
        return function(Get<VIndex>(Forward<TTuples>(tuples))...);
    }

    template <typename TFunction, typename TTuple, typename... TTuples>
    constexpr void ApplyLockstep(TFunction&& function, TTuple&& tuple, TTuples&&... tuples) noexcept
    {
        static_assert(Templates::SameRank<Templates::Decay<TTuple>, Templates::Decay<TTuples>...>, "Tuples must have the same rank.");

        using TSequence = Templates::MakeSequence<Templates::Rank<Templates::Decay<TTuple>>>;

        Details::ApplyLockstep(TSequence{}, Forward<TFunction>(function), Forward<TTuple>(tuple), Forward<TTuples>(tuples)...);
    }
}

// ===========================================================================