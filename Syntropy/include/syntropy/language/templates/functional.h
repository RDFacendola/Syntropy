
/// \file functional.h
/// \brief This header is part of the Syntropy language module. It contains definitions for functional-style templates.
///
/// \author Raffaele D. Facendola - November 2020

#pragma once

#include "syntropy/language/foundation/types.h"
#include "syntropy/language/foundation/references.h"
#include "syntropy/language/templates/rank.h"
#include "syntropy/language/templates/sequences.h"

#include "syntropy/language/templates/details/functional_details.h"

// ===========================================================================

namespace Syntropy::Templates
{
    /************************************************************************/
    /* FUNCTION ARGUMENTS                                                   */
    /************************************************************************/

    /// \brief Type alias equal to the argument types a callable object can be called with.
    /// If no matching element could be found, the program is ill-formed.
    template <typename TCallable>
    using FunctionArguments = Details::FunctionArguments<TCallable>;

    /************************************************************************/
    /* LOCKSTEP                                                             */
    /************************************************************************/

    /// \brief Apply a function passing the VIndex-th element of each tuple-like object as function arguments.
    /// \remarks Tuple elements are accessed by means of Get<Int>(tuple) function, which is expected to be defined for each type in TTuples.
    template <Int VIndex, typename TFunction, typename... TTuples>
    constexpr decltype(auto) ApplyAt(TFunction&& function, TTuples&&... tuples) noexcept;

    /// \brief Apply a function to all argument list generated by projecting the i-th element of all provided tuples, in the same order, for each index i.
    /// \remarks Tuple elements are accessed by means of Get<Int>(tuple) function, which is expected to be defined for each type in TTuples.
    template <typename TFunction, typename TTuple, typename... TTuples>
    constexpr void ApplyLockstep(TFunction&& function, TTuple&& tuple, TTuples&&... tuples) noexcept;
}

// ===========================================================================

namespace Syntropy::Templates
{
    /************************************************************************/
    /* IMPLEMENTATION                                                       */
    /************************************************************************/

    // Lockstep.
    // =========

    template <Int VIndex, typename TFunction, typename... TTuples>
    constexpr decltype(auto) ApplyAt(TFunction&& function, TTuples&&... tuples) noexcept
    {
        return function(Get<VIndex>(Forward<TTuples>(tuples))...);
    }

    template <typename TFunction, typename TTuple, typename... TTuples>
    constexpr void ApplyLockstep(TFunction&& function, TTuple&& tuple, TTuples&&... tuples) noexcept
    {
        static_assert(SameRank<TTuple, TTuples...>, "Tuples must have the same rank.");

        using TSequence = MakeIntegerSequence<Rank<TTuple>>;

        Details::ApplyLockstep(TSequence{}, Forward<TFunction>(function), Forward<TTuple>(tuple), Forward<TTuples>(tuples)...);
    }
}

// ===========================================================================